// ============================================================================
// 外部声明和基本类型定义
// ============================================================================

// size_t: 无符号长整型,用于表示内存大小,在64位系统上通常是8字节
typedef unsigned long size_t;

// uintptr_t: 无符号长整型,用于存储指针值进行算术运算
typedef unsigned long uintptr_t;

// NULL: 空指针的宏定义,强制转换为void*类型
#define NULL ((void *)0)

// POOL_SIZE: 内存池总大小为8MB (8 * 1024 * 1024字节)
// 这是我们自己管理的内存区域,所有内存分配都从这个池中进行
#define POOL_SIZE (8 * 1024 * 1024)

// 外部声明:实际的内存池数组在其他文件中定义
// 这是一个8MB的字符数组,作为我们的内存池
extern char my_mem_pool[POOL_SIZE];

// ============================================================================
// 内存块头部结构定义
// ============================================================================

// 每个内存块(无论是已分配还是空闲)都有一个头部,用于管理元数据
typedef struct block_header {
    size_t size;              // 块的总大小(包含头部本身的大小)
                              // 例如:如果用户请求100字节,这个值可能是132
                              // (100字节数据 + 32字节头部,向上对齐)
    
    struct block_header *next; // 指向下一个空闲块的指针
                              // 只在块为空闲状态时使用,形成空闲链表
                              // 已分配的块不需要这个字段
    
    int is_free;              // 标记位: 1表示空闲, 0表示已分配
                              // 用于防止重复释放和验证块状态
    
    int magic;                // 魔数:固定值0xDEADBEEF,用于验证块的有效性
                              // 如果这个值不对,说明内存可能被破坏
} block_header_t;

// ============================================================================
// 核心常量定义
// ============================================================================

// HEADER_SIZE: 块头部的大小(字节),在64位系统上通常是32字节
// 这是每个内存块的开销,用户看不到但必须占用空间
#define HEADER_SIZE sizeof(block_header_t)

// MAGIC_NUMBER: 魔数值,用于验证内存块是否有效
// 0xDEADBEEF是一个常用的魔数,容易识别且不太可能随机出现
#define MAGIC_NUMBER 0xDEADBEEF

// ALIGNMENT: 内存对齐字节数,设为8字节
// 原因:现代CPU访问8字节对齐的地址更高效,可以提高性能
// 例如:如果用户请求13字节,实际会分配16字节(向上对齐到8的倍数)
#define ALIGNMENT 8

// MAX_ALLOC_SIZE: 单次最大分配大小限制为4KB
// 防止单次分配占用过多内存,也是一种保护机制
#define MAX_ALLOC_SIZE 4096

// MIN_BLOCK_SIZE: 最小块大小为32字节(不包含头部)
// 太小的块会导致过度碎片化,这个值平衡了空间利用率和碎片问题
#define MIN_BLOCK_SIZE 32

// ============================================================================
// 隔离空闲链表(Segregated Free Lists)数据结构
// ============================================================================

// 什么是隔离空闲链表?
// 传统的单一空闲链表需要遍历整个链表来查找合适大小的块,效率低下。
// 隔离空闲链表将不同大小的空闲块分别存储在不同的链表中,
// 分配时可以直接找到合适大小范围的链表,大大提高查找效率。

// NUM_SIZE_CLASSES: 大小类别的数量,我们分为10个类别
#define NUM_SIZE_CLASSES 10

// free_lists: 空闲链表数组,每个元素是一个链表的头指针
// 例如: free_lists[0]存储32字节以下的空闲块
//       free_lists[1]存储33-64字节的空闲块
//       依此类推
static block_header_t *free_lists[NUM_SIZE_CLASSES];

// size_class_limits: 每个大小类别的上限(字节)
// 索引0: <= 32字节
// 索引1: <= 64字节
// 索引2: <= 128字节
// ...
// 索引9: 无限大(用-1表示,实际是size_t的最大值)
static size_t size_class_limits[NUM_SIZE_CLASSES] = {
    32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, (size_t)-1
};

// ============================================================================
// 辅助函数: 内存对齐
// ============================================================================

// 功能:将给定的size向上对齐到ALIGNMENT(8字节)的倍数
// 原理:使用位运算实现高效对齐
// 
// 算法解释:
// 1. (size + ALIGNMENT - 1): 先加7,确保向上取整
// 2. ~(ALIGNMENT - 1): 创建掩码 ~7 = ...11111000 (二进制)
// 3. 与运算: 将低3位清零,实现8字节对齐
// 
// 例子: size=13
//   13 + 7 = 20 = 0b10100
//   ~7 = 0b...11111000
//   20 & ~7 = 0b10000 = 16 (对齐后)
static size_t align_size(size_t size) {
    return (size + ALIGNMENT - 1) & ~(ALIGNMENT - 1);
}

// ============================================================================
// 辅助函数: 获取大小类别索引
// ============================================================================

// 功能:根据请求的大小,确定应该使用哪个空闲链表
// 参数: size - 用户请求的字节数(不包含头部)
// 返回: 对应的size class索引 (0到NUM_SIZE_CLASSES-1)
// 
// 例子: size=100 -> 返回3 (因为100 <= 128)
//       size=1000 -> 返回5 (因为1000 <= 1024)
static int get_size_class(size_t size) {
    // 遍历所有大小类别
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
        // 找到第一个上限大于等于size的类别
        if (size <= size_class_limits[i]) {
            return i;
        }
    }
    // 如果都不满足(理论上不会发生),返回最大类别
    return NUM_SIZE_CLASSES - 1;
}

// ============================================================================
// 辅助函数: 检查指针是否在内存池范围内
// ============================================================================

// 功能:验证给定指针是否指向我们管理的内存池
// 这是一个安全检查,防止操作野指针
// 
// 参数: ptr - 要检查的指针
// 返回: 1表示在池内, 0表示不在
// 
// 检查逻辑:
// 1. ptr >= my_mem_pool的起始地址
// 2. ptr < my_mem_pool的结束地址(起始+大小)
static int in_pool(void *ptr) {
    return (ptr >= (void *)my_mem_pool) &&
           (ptr < (void *)(my_mem_pool + POOL_SIZE));
}

// ============================================================================
// 辅助函数: 验证块头部的有效性
// ============================================================================

// 功能:检查一个内存块的头部是否有效
// 这是多层防御机制,用于检测内存损坏
// 
// 检查项目:
// 1. 块是否在内存池范围内
// 2. 魔数是否正确(防止内存损坏)
// 3. 块大小是否合理(不能小于头部,不能超过池大小)
static int is_valid_block(block_header_t *block) {
    // 检查1: 块必须在池内
    if (!in_pool(block)) return 0;
    
    // 检查2: 魔数必须匹配
    // 如果不匹配,可能是内存被覆写或者这根本不是有效的块
    if (block->magic != MAGIC_NUMBER) return 0;
    
    // 检查3: 块大小必须至少包含头部
    if (block->size < HEADER_SIZE) return 0;
    
    // 检查4: 块大小不能超过整个内存池
    if (block->size > POOL_SIZE) return 0;
    
    return 1;
}

// ============================================================================
// 辅助函数: 将块添加到空闲链表
// ============================================================================

// 功能:将一个空闲块添加到对应大小类别的空闲链表中
// 
// 参数: block - 要添加的块
// 
// 工作流程:
// 1. 计算用户可用空间大小(总大小-头部大小)
// 2. 根据大小确定应该加入哪个链表
// 3. 使用头插法将块插入链表(时间复杂度O(1))
static void add_to_free_list(block_header_t *block) {
    // 计算用户可用空间:总大小减去头部大小
    size_t user_size = block->size - HEADER_SIZE;
    
    // 确定这个块属于哪个大小类别
    int class_idx = get_size_class(user_size);
    
    // 标记为空闲
    block->is_free = 1;
    
    // 头插法:将新块插入到链表头部
    // 新块的next指向原来的链表头
    block->next = free_lists[class_idx];
    
    // 更新链表头为新块
    free_lists[class_idx] = block;
}

// ============================================================================
// 辅助函数: 从空闲链表中移除块
// ============================================================================

// 功能:将一个块从空闲链表中移除 (通常是因为要分配它)
// 
// 参数: block - 要移除的块
// 
// 工作流程:
// 1. 确定块所在的链表
// 2. 遍历链表找到该块
// 3. 修改前驱节点的next指针,跳过该块
// 4. 清理块的next指针和is_free标志
static void remove_from_free_list(block_header_t *block) {
    // 计算用户可用大小,确定在哪个链表中
    size_t user_size = block->size - HEADER_SIZE;
    int class_idx = get_size_class(user_size);
    
    // current: 指向当前遍历位置的指针的指针(二级指针)
    // 使用二级指针的好处:可以直接修改链表头或前驱节点的next指针
    block_header_t **current = &free_lists[class_idx];
    
    // 遍历链表
    while (*current) {
        // 找到要移除的块
        if (*current == block) {
            // 将前驱的next指向block的next,从而跳过block
            *current = block->next;
            
            // 清理block的链接
            block->next = NULL;
            
            // 标记为已分配
            block->is_free = 0;
            
            return;
        }
        
        // 移动到下一个节点
        // current指向当前节点的next字段的地址
        current = &((*current)->next);
    }
}

// ============================================================================
// 辅助函数: 合并相邻的空闲块
// ============================================================================

// 功能:尝试将当前块与其物理上相邻的下一个块合并
// 这是减少内存碎片的关键技术
// 
// 参数: block - 当前块
// 
// 为什么需要合并?
// 例子: 用户先分配3个64字节的块 A, B, C
//       然后释放 A 和 B
//       如果不合并,只能分配<=64字节的请求
//       合并后得到128字节的块,可以满足更大的请求
// 
// 工作流程:
// 1. 计算下一个块的位置(当前块地址+当前块大小)
// 2. 检查下一个块是否有效且空闲
// 3. 如果满足条件,从链表移除下一个块
// 4. 合并两个块(增加当前块的大小)
// 5. 使下一个块的头部失效
static void coalesce_next(block_header_t *block) {
    // 计算下一个块的地址
    // block是块的起始地址,加上块的大小就是下一个块的位置
    char *block_end = (char *)block + block->size;
    block_header_t *next = (block_header_t *)block_end;
    
    // 检查下一个块是否可以合并
    // 条件1: 下一个块的地址必须在池内
    // 条件2: 下一个块的头部完全在池内(地址+头部大小<=池结束)
    // 条件3: 下一个块的头部有效(魔数等检查)
    // 条件4: 下一个块必须是空闲的
    if (in_pool(next) && 
        (char *)next + HEADER_SIZE <= my_mem_pool + POOL_SIZE &&
        is_valid_block(next) && 
        next->is_free) {
        
        // 从空闲链表中移除下一个块
        // 因为它即将被合并,不再独立存在
        remove_from_free_list(next);
        
        // 合并:将下一个块的大小加到当前块
        // 现在block代表两个块合并后的大块
        block->size += next->size;
        
        // 使下一个块的魔数失效
        // 这样如果有人误用这个块,会被检测出来
        next->magic = 0;
    }
}

// ============================================================================
// 辅助函数: 分割过大的块
// ============================================================================

// 功能:如果找到的空闲块太大,将其分割成两部分
// 这样可以提高内存利用率,减少内部碎片
// 
// 参数: 
//   block - 要分割的块
//   required_size - 需要的大小(包含头部)
// 
// 例子: 
//   用户请求64字节,找到一个1024字节的块
//   分割后:前面64字节分配给用户,剩余960字节作为新的空闲块
// 
// 工作流程:
// 1. 计算剩余空间
// 2. 如果剩余空间足够大(>=最小块+头部),才分割
// 3. 在原块后面创建新的空闲块
// 4. 更新原块大小
// 5. 将新块加入空闲链表
static void split_block(block_header_t *block, size_t required_size) {
    // 计算分割后的剩余空间
    size_t remaining = block->size - required_size;
    
    // 只有剩余空间足够大时才分割
    // 如果剩余空间太小,不如直接全部分配(减少碎片)
    // 判断条件:剩余空间 >= 头部大小 + 最小块大小(32字节)
    if (remaining >= HEADER_SIZE + MIN_BLOCK_SIZE) {
        // 在原块后面创建新的空闲块
        // 新块位置 = 原块起始地址 + 需要的大小
        block_header_t *new_block = (block_header_t *)((char *)block + required_size);
        
        // 设置新块的大小(剩余的所有空间)
        new_block->size = remaining;
        
        // 设置魔数,标记为有效块
        new_block->magic = MAGIC_NUMBER;
        
        // 标记为空闲
        new_block->is_free = 1;
        
        // 初始化next指针为NULL
        new_block->next = NULL;
        
        // 更新原块的大小为需要的大小
        block->size = required_size;
        
        // 将新创建的空闲块加入空闲链表
        // 这样它可以被后续的分配请求使用
        add_to_free_list(new_block);
    }
    // 如果剩余空间不够,不分割,全部分配给用户
    // 这会造成少量内部碎片,但避免了过度碎片化
}

// ============================================================================
// 主函数: 初始化内存池
// ============================================================================

// 功能:初始化整个内存分配器
// 调用时机:程序启动时调用一次
// 
// 工作内容:
// 1. 初始化所有空闲链表为空
// 2. 将整个内存池作为一个大的空闲块
// 3. 将这个大块加入到合适的空闲链表中
// 
// noinline属性:禁止编译器内联这个函数,方便调试和性能分析
void __attribute__((noinline)) my_init() {
    // 步骤1: 初始化所有空闲链表为空
    // 遍历所有大小类别,将链表头指针设为NULL
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
        free_lists[i] = NULL;
    }
    
    // 步骤2: 创建初始的大空闲块
    // 将内存池的起始地址作为第一个块的地址
    block_header_t *initial_block = (block_header_t *)my_mem_pool;
    
    // 这个块占据整个内存池(8MB)
    initial_block->size = POOL_SIZE;
    
    // 设置魔数,标记为有效块
    initial_block->magic = MAGIC_NUMBER;
    
    // 标记为空闲
    initial_block->is_free = 1;
    
    // 初始化next为NULL(当前是唯一的块)
    initial_block->next = NULL;
    
    // 步骤3: 将这个大块加入到空闲链表
    // add_to_free_list会根据大小自动选择合适的链表
    add_to_free_list(initial_block);
}

// ============================================================================
// 主函数: 分配内存
// ============================================================================

// 功能:分配指定大小的内存块
// 参数: size - 用户请求的字节数
// 返回: 成功返回指向可用内存的指针,失败返回NULL
// 
// 注意:返回的指针指向用户可用区域,不包含头部
//      头部在返回指针之前,对用户透明
// 
// 分配策略:首次适配(First Fit)
//   从合适的大小类别开始,找到第一个足够大的块就分配
//   优点:速度快
//   缺点:可能不是最佳匹配
void * __attribute__((noinline)) my_malloc(size_t size) {
    // ========== 参数验证阶段 ==========
    
    // 检查1: 零大小请求
    // 按照标准,malloc(0)的行为是实现定义的
    // 我们选择返回NULL
    if (size == 0) {
        return NULL;
    }
    
    // 检查2: 超过最大分配限制
    // 防止单次分配过大,保护内存池
    if (size > MAX_ALLOC_SIZE) {
        return NULL;
    }
    
    // ========== 大小计算阶段 ==========
    
    // 步骤1: 将请求大小向上对齐到8字节
    // 例如:请求13字节,对齐后16字节
    size_t aligned_size = align_size(size);
    
    // 步骤2: 加上头部大小,得到总大小
    // 这是块的实际占用大小
    size_t total_size = aligned_size + HEADER_SIZE;
    
    // 步骤3: 确保满足最小块大小要求
    // 如果total_size太小,提升到最小值
    // 这样可以减少过度碎片化
    if (total_size < MIN_BLOCK_SIZE + HEADER_SIZE) {
        total_size = MIN_BLOCK_SIZE + HEADER_SIZE;
    }
    
    // ========== 查找合适的块 ==========
    
    // 确定起始搜索的大小类别
    // 例如:请求64字节,从class 1(64字节类别)开始搜索
    int start_class = get_size_class(aligned_size);
    
    // 从起始类别开始,向更大的类别搜索
    // 原因:小类别不够大,直接跳过,提高效率
    for (int class_idx = start_class; class_idx < NUM_SIZE_CLASSES; class_idx++) {
        // 获取当前类别的空闲链表头
        block_header_t *current = free_lists[class_idx];
        
        // prev_ptr: 指向当前节点指针的指针(二级指针)
        // 用于在找到合适块后,直接从链表中移除
        block_header_t **prev_ptr = &free_lists[class_idx];
        
        // 遍历当前大小类别的空闲链表
        while (current) {
            // 检查当前块是否满足要求
            // 条件1: 块是空闲的(双重保险,链表中应该都是空闲的)
            // 条件2: 块足够大
            if (current->is_free && current->size >= total_size) {
                // ========== 找到合适的块! ==========
                
                // 步骤1: 从空闲链表中移除这个块
                // 使用二级指针,直接修改前驱的next
                *prev_ptr = current->next;
                current->next = NULL;
                
                // 步骤2: 标记为已分配
                current->is_free = 0;
                
                // 步骤3: 如果块太大,进行分割
                // split_block内部会判断是否需要分割
                split_block(current, total_size);
                
                // 步骤4: 返回用户可用区域的指针
                // 用户不需要知道头部的存在
                // 跳过头部,返回数据区的起始地址
                return (void *)((char *)current + HEADER_SIZE);
            }
            
            // 当前块不合适,继续查找下一个
            prev_ptr = &(current->next);
            current = current->next;
        }
    }
    
    // ========== 分配失败 ==========
    // 遍历了所有大小类别的所有空闲块,都没有找到合适的
    // 原因可能是:
    // 1. 内存池已满
    // 2. 有足够的总空闲空间,但过于碎片化
    return NULL;
}

// ============================================================================
// 主函数: 释放内存
// ============================================================================

// 功能:释放之前分配的内存块
// 参数: ptr - 指向要释放的内存的指针(由my_malloc返回)
// 
// 工作流程:
// 1. 参数验证(NULL检查,范围检查)
// 2. 通过指针找到块头部
// 3. 验证块的有效性
// 4. 检查重复释放
// 5. 标记为空闲
// 6. 尝试合并相邻块
// 7. 加入空闲链表
void __attribute__((noinline)) my_free(void *ptr) {
    // ========== 参数验证阶段 ==========
    
    // 检查1: NULL指针
    // free(NULL)是合法的,应该直接返回
    if (ptr == NULL) {
        return;
    }
    
    // 检查2: 指针必须在内存池范围内
    // 防止释放不属于我们管理的内存
    if (!in_pool(ptr)) {
        return;  // 静默失败,不崩溃
    }
    
    // ========== 获取块头部 ==========
    
    // 用户传入的指针指向数据区
    // 块头部在数据区之前,向前偏移HEADER_SIZE字节
    // 
    // 内存布局:
    //   [块头部 32字节] [用户数据区]
    //   ^              ^
    //   block          ptr (用户看到的指针)
    block_header_t *block = (block_header_t *)((char *)ptr - HEADER_SIZE);
    
    // ========== 验证块的有效性 ==========
    
    // 检查块头部是否有效
    // 包括:魔数检查、大小检查等
    if (!is_valid_block(block)) {
        return;  // 无效块,可能是内存损坏或野指针
    }
    
    // ========== 防止重复释放 ==========
    
    // 检查块是否已经是空闲状态
    // 重复释放会导致链表结构混乱
    if (block->is_free) {
        return;  // 已经释放过了,忽略(静默失败而不是崩溃)
    }
    
    // ========== 释放块 ==========
    
    // 步骤1: 标记为空闲
    block->is_free = 1;
    
    // 步骤2: 尝试与后面的块合并
    // 这是减少碎片的关键步骤
    // 如果后面紧邻的块也是空闲的,就合并成一个大块
    coalesce_next(block);
    
    // 步骤3: 将块加入到对应的空闲链表
    // 这样它可以被后续的分配请求使用
    // add_to_free_list会根据块的大小自动选择合适的链表
    add_to_free_list(block);
    
    // 注意:我们没有与前面的块合并
    // 原因:需要遍历找到前面的块比较复杂
    // 只合并后面的块已经能有效减少碎片
}